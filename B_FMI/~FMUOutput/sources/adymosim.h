#ifndef adymosim_h
#define adymosim_h

/*
 * Copyright (C) 1997-2001 Dynasim AB.
 * All rights reserved.
 *
 */

/* 
   Write and/or read the input data for a Dymosim simulation.

   Functions:
      adymosimRead : Read input data from file.
      adymosimWrite: Write input data to file.

      adymosimNew  : Allocate storage for a new Dymosim simulation-input data object
                     and initialize it (set default values).
      adymosimInit : Initialize a new Dymosim simulation-input data object
                     (set default values).
      adymosimDel  : Delete the contents of a Dymosim simulation-input data object.

   Example:
      Adymosim sim;
      
      // Initialize a new object.
         adymosimInit(&sim);

      // Set specific values of object.
             ...

      // Write object to file.
         if ( adymosimWrite("temp.mat", amatASCII, sim, "Generated by Dymodraw") != 0 ) goto ERROR;
         return;

      // Error handling (amatError is a global variable, defined in "amat.h")
         ERROR: fprintf(stderr,"Error in program XXX:\n%s",amatError);
                return 1;
*/

#include "amat.h"


typedef struct {
   doublereal t0    ;     /* Initial simulation time                      */
   doublereal tend  ;     /* Final simulation time                        */
   doublereal dtco  ;     /* Communication stepsize                       */
   integer    ncom  ;     /* Number of communication intervals            */
   doublereal tolr  ;     /* Relative scalar tolerance                    */
   doublereal hfix  ;     /* Step size of fixed step size integrator      */
   integer    imeth ;     /* Integration method as integer (1...10)       */
} AdymosimExperiment;


typedef struct {
   integer    grid  ;     /* 1/2/3/4/5 equidistant/vector of points/       */
                          /*           automatic/model/hardware-clock      */
   integer    nt    ;     /* Use every NT time instant, if GRID = 3        */
   integer    dense ;     /* 1/2/3 restart/step/interpol. GRID points      */
   integer    evgrid;     /* 0/1 do not/save event points in time grid     */
   integer    evu   ;     /* 0/1 U-discontinuity does not/triggers event   */
   integer    evuord;     /* U-discontinuity order to consider (0,1,...)   */
   integer    error ;     /* 0/1/2 One message/warning/error messages      */
   integer    jac   ;     /* 0/1 Compute jacobian numerically/by BLOCKJ    */
   integer    xd0c  ;     /* 0/1 Compute/set XD0                           */
   integer    f3    ;     /* 0/1 Ignore/use F3 of HDAE (= index 1)         */
   integer    f4    ;     /* 0/1 Ignore/use F4 of HDAE (= index 2)         */
   integer    f5    ;     /* 0/1 Ignore/use F5 of HDAE (= invar.)          */
   integer    debug ;     /* flags for debug information (1<<0 uses pdebug)*/
   integer    pdebug;     /* priority of debug information (1...100)       */
   integer    fmax  ;     /* Maximum number of evaluations of BLOCKF       */
   integer    ordmax;     /* Maximum allowed integration order             */
   doublereal hmax  ;     /* Maximum absolute stepsize                     */
   doublereal hmin  ;     /* Minimum absolute stepsize (use with care!)    */
   doublereal h0    ;     /* Stepsize to be attempted on first step        */
   doublereal teps  ;     /* Bound to check, if 2 equal time instants      */
   doublereal eveps ;     /* Hysteresis epsilon at event points            */
   integer    eviter;     /* Maximum number of event iterations            */
   doublereal delaym;     /* Minimum time increment in delay buffers       */
   integer    fexcep;     /* 0/1 floating exception crashes/stops dymosim  */
   doublereal tscale;     /* simulation-clock/hardware-clock, if grid = 5  */
   integer    shared;     /* type of process communication, if grid = 5    */
                          /* = 0: no communication,                        */
                          /*      (single process without clock)           */
                          /* = 1: no communication                         */
                          /*      (single process with clock)              */
                          /* = 2: shared memory                            */
                          /*      (multiple processes with clock)          */
   integer    memkey;     /* key to be used for shared memory, if shared=1 */
} AdymosimMethod;


typedef struct {
   integer lprec ;    /* 0/1 do not/store result data in double       */
   integer lx    ;    /* 0/1 do not/store x                           */
   integer lxd   ;    /* 0/1 do not/store xd                          */
   integer lu    ;    /* 0/1 do not/store u                           */
   integer ly    ;    /* 0/1 do not/store y                           */
   integer lz    ;    /* 0/1 do not/store z (used for non-filtered)   */
   integer lw    ;    /* 0/1 do not/store w                           */
   integer la    ;    /* 0/1 do not/store a (alias variables)         */
   integer lperf ;    /* 0/1 do not/store (used for protected)        */
   integer levent;    /* 0/1 do not/store event type                  */
   integer lres  ;    /* 0/1 do not/store results on result file      */
   integer lshare;    /* 0/1 do not/store info data for shared memory */
   integer lform ;    /* 0/1 do not/store in binary format            */
} AdymosimSettings;


typedef enum {
  dsFixed  ,      /* Initial variable is fixed                  */
  dsFree   ,      /* Initial variable is free                   */
  dsDesired,       /* Initial variable is desired (has a weight) */
  dsSimulated    /* Initial variable was the result of a simulation, thus overriding start-values in model */
} dsWeightType;


typedef enum {
	dsParameter = 1,
	dsState = 2,
	dsDerivative = 3,
	dsOutput = 4,
	dsInput = 5,
	dsAux = 6,
	dsAlias = 7,
	dsStringParameter = 8,
	dsStringVariable = 9,
	dsInput2 = 10,
	dsDState = 11,
	dsPrevious = 12,
	dsStringParameter2 = 13,
	dsParameter2 = 14,
	dsSystemVar = 15
} dsCategory;     /* category of variable */


typedef enum {
  dsReal=0    ,
  dsBoolean=1 ,
  dsInteger=2 ,
  dsBaseTypeMask=3,
  dsConnector=4,
  dsNormalStart=8,
  dsContinueStart=16,
  dsOptionalStart=32,
  dsStartMasks=56,
  dsDiscrete=64,
  dsFlow=128,
  dsReserved=256,
  dsStoreMask=512|1024,
  dsStoredPublic=0,
  dsNonStored=512,
  dsProtected=1024,
  dsStoredProtected=512|1024,
  dsIsFiltered=2048
} dsBaseType;    /* basic data type of variable */


typedef struct {
   doublereal     value;     /* Initial value, initial guess or desired value  */
   doublereal     weight;    /* Weight of initial value (>=0)                  */
   doublereal     minimum;   /* Minimum value (used for search area)           */
   doublereal     maximum;   /* Maximum value (used for search area)           */
                             /* if minimum >= maximum, the two values are      */
                             /* ignored                                        */
   doublereal     nominal;   /* Nominal value (used for scaling)               */
   dsWeightType   type:8;      /* Type of initial value                          */
   dsCategory     category:8;  /* Category of variable                           */
   dsBaseType     basetype:16;  /* Basic data type of variable, and other flags   */
   doublereal     origvalue;
} AdymosimInitial;

typedef struct Adymosim {
   AdymosimExperiment m     ;  /* experiment parameters        */
   AdymosimMethod     m2    ;  /* tuning parameters            */
   AdymosimSettings   s     ;  /* output setting               */

   integer            ntgrid;  /* number of time grid points             */
   doublereal        *tgrid ;  /* tgrid[ntgrid] explicit comm. time grid */

   integer            ndp;     /* number of double  parameters           */
   integer            nip;     /* number of integer parameters           */
   integer            nlp;     /* number of logical parameters           */
   integer            np;      /* total number of parameters             */
                               /* (np = ndp + nip + nlp)                 */
   integer            nx;      /* number of state variables              */
   integer            nu;      /* number of input variables              */
   integer            ny;      /* number of output variables             */
   integer            nw;      /* number of auxililary variables         */
   integer            ni;      /* number of initial variables            */
                               /* (ni = np + nx + nx + ny + nu + nw)     */
   char             **iname;   /* names of initial variables             */
                               /* (char *iname[ni])                      */
   char             **idesc;   /* description of initial variables       */
                               /* (char *iname[ni])*/
   AdymosimInitial  *initial;  /* initial variables (no longer ordered): */
                               /* parameters, states, state derivatives, */
                               /* outputs, inputs (initial[ni])          */
} Adymosim;


#ifdef __cplusplus
extern "C" {
#endif
extern Adymosim* adymosimRead (const char *fileName, Adymosim *sim);
   /* Read Adymosim object from file 
      -> fileName: Name of file
      -> sim     : if sim == NULL then
                      a new structure is allocated and returned filled with
                      the data from the file.
                   else
                      The provided values in "sim" are used as default values.
                      If e.g. sim.m2 is not present on file, the provided 
                      values are used. Default values and storage must be 
                      provided for ALL variables of "sim" with the exception 
                      of "ntgrid" and "tgrid". The array "iname" will not be
                      changed by adymosimRead. "iname" is used to identify the
                      places in which data from file has to be copied. 
      <- RETURN  : = NULL: an error occured; the error message is stored
                           as (static) string in global variable "amatError".
                   else  : Object of type Adymosim read from file.
   */


extern Adymosim* adymosimCopy(const Adymosim *sim);
   /* Copy complete Adymosim structure
      -> sim   : Adymosim structure to be copied.
      <- RETURN: Newly allocated Adymosim structure which is identical
                 to "sim".
   */
   

extern int adymosimWrite (const char *fileName, AmatFileType ftype, Adymosim sim, char *descr);
   /* Write object of type Adymosim on file
      -> fileName: Filename
      -> ftype   : File format (amatASCII, amatBinary)
      -> sim     : Dymosim simulation input data (some components may be missing).
      -> descr   : Description text stored on file
      <- RETURN  : = 0 : no error occurs.
                   else: an error occured; the error message is stored
                         as (static) string in global variable "amatError".
   */

extern int adymosimWriteOld (const char *fileName, AmatFileType ftype, Adymosim sim, 
                             char *descr, doublereal *xscale);
   /* same as adymosimWrite, but writing routine for old version 1.1
      -> xscale[sim->nx]: used xscale factors.
   */

extern void adymosimXscale (Adymosim *sim, doublereal xscale[]);
   /* Compute xscale factors 
      -> sim   : initial values
      <- xscale: scale factors   (double xscale[sim->nx])
   */

extern Adymosim *adymosimNew(void);
    /* Generate a new Adymosim object
       <- RETURN: > 0: Pointer to new, initialized Adymosim object.
                  = 0: An error occured; the error message is stored
                       as (static) string in global variable "amatError".
    */


extern void adymosimInit (Adymosim *sim);
   /* Initialize object of type Adymosim. Components sim.m, sim.m2, sim.s are
      initialized with their default values. The dimensions (sim.ndp,...)
      are initialized with 0, and the data pointers (sim.initial,...)
      are initialized with NULL.
      <- sim : Initialized Adymosim object. 
   */


extern void adymosimDel (Adymosim *sim);
   /* Delete storage of the components of a Adymosim object */

extern double adymosimGetScale(double vMin, double vMax, double vNom);
   /* return scale-factor for given minimum, maximum, and nominal value */
   /* Previously used only minimum and maximum, but now only uses nominal value */

#if defined(__cplusplus)
}
#endif


#endif
